# 07-部署与运维设计之2

## 2. CI/CD流水线设计

### 2.1 流水线架构

#### 整体CI/CD架构

```mermaid
graph TB
    subgraph "代码管理"
        A1[Git Repository]
        A2[Feature Branch]
        A3[Main Branch]
    end
    
    subgraph "CI阶段"
        B1[代码检查]
        B2[单元测试]
        B3[集成测试]
        B4[安全扫描]
        B5[构建镜像]
    end
    
    subgraph "CD阶段"
        C1[部署测试环境]
        C2[自动化测试]
        C3[部署预生产]
        C4[用户验收测试]
        C5[部署生产环境]
    end
    
    subgraph "监控反馈"
        D1[性能监控]
        D2[错误监控]
        D3[用户反馈]
        D4[回滚机制]
    end
    
    A1 --> A2
    A2 --> B1
    B1 --> B2
    B2 --> B3
    B3 --> B4
    B4 --> B5
    B5 --> C1
    C1 --> C2
    C2 --> C3
    C3 --> C4
    C4 --> C5
    C5 --> D1
    D1 --> D2
    D2 --> D3
    D3 --> D4
    
    classDef code fill:#e3f2fd,stroke:#1565c0,stroke-width:2px,color:#0d47a1
    classDef ci fill:#f3e5f5,stroke:#6a1b9a,stroke-width:2px,color:#4a148c
    classDef cd fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px,color:#1b5e20
    classDef monitor fill:#ffebee,stroke:#c62828,stroke-width:2px,color:#b71c1c
    
    class A1,A2,A3 code
    class B1,B2,B3,B4,B5 ci
    class C1,C2,C3,C4,C5 cd
    class D1,D2,D3,D4 monitor
```

#### GitHub Actions配置

```yaml
# .github/workflows/ci-cd.yml
name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # 代码质量检查
  code-quality:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run linting
        run: npm run lint

      - name: Run type checking
        run: npm run type-check

      - name: Run code formatting check
        run: npm run format:check

  # 单元测试
  unit-tests:
    runs-on: ubuntu-latest
    needs: code-quality
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: iam_test
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

      redis:
        image: redis:7
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 6379:6379

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run unit tests
        run: npm run test:unit
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/iam_test
          REDIS_URL: redis://localhost:6379

      - name: Run integration tests
        run: npm run test:integration
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/iam_test
          REDIS_URL: redis://localhost:6379

      - name: Upload coverage reports
        uses: codecov/codecov-action@v3
        with:
          file: ./coverage/lcov.info

  # 安全扫描
  security-scan:
    runs-on: ubuntu-latest
    needs: unit-tests
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Run SAST scan
        uses: github/codeql-action/init@v2
        with:
          languages: javascript

      - name: Perform CodeQL Analysis
        uses: github/codeql-action/analyze@v2

      - name: Run dependency vulnerability scan
        run: npm audit --audit-level moderate

      - name: Run container security scan
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}
          format: 'sarif'
          output: 'trivy-results.sarif'

  # 构建和推送镜像
  build-and-push:
    runs-on: ubuntu-latest
    needs: [unit-tests, security-scan]
    if: github.event_name == 'push'
    permissions:
      contents: read
      packages: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  # 部署到测试环境
  deploy-test:
    runs-on: ubuntu-latest
    needs: build-and-push
    if: github.ref == 'refs/heads/develop'
    environment: test
    steps:
      - name: Deploy to test environment
        run: |
          echo "Deploying to test environment..."
          # 这里可以集成具体的部署脚本
          # 例如：kubectl apply -f k8s/test/
          # 或者：docker-compose -f docker-compose.test.yml up -d

      - name: Run smoke tests
        run: |
          echo "Running smoke tests..."
          # 运行冒烟测试确保部署成功

  # 部署到生产环境
  deploy-production:
    runs-on: ubuntu-latest
    needs: build-and-push
    if: github.ref == 'refs/heads/main'
    environment: production
    steps:
      - name: Deploy to production
        run: |
          echo "Deploying to production environment..."
          # 生产环境部署脚本

      - name: Run health checks
        run: |
          echo "Running health checks..."
          # 健康检查确保服务正常运行
```

### 2.2 自动化测试

#### 测试策略设计

```typescript
// test/strategy/test-strategy.ts
export interface TestStrategy {
  // 单元测试策略
  unit: {
    coverage: number; // 覆盖率要求
    timeout: number; // 超时时间
    parallel: boolean; // 是否并行执行
  };
  
  // 集成测试策略
  integration: {
    database: boolean; // 是否包含数据库测试
    redis: boolean; // 是否包含Redis测试
    external: boolean; // 是否包含外部服务测试
  };
  
  // 端到端测试策略
  e2e: {
    browser: string[]; // 支持的浏览器
    mobile: boolean; // 是否包含移动端测试
    performance: boolean; // 是否包含性能测试
  };
  
  // 性能测试策略
  performance: {
    load: boolean; // 负载测试
    stress: boolean; // 压力测试
    spike: boolean; // 尖峰测试
  };
}

export const defaultTestStrategy: TestStrategy = {
  unit: {
    coverage: 80,
    timeout: 5000,
    parallel: true,
  },
  integration: {
    database: true,
    redis: true,
    external: false,
  },
  e2e: {
    browser: ['chrome', 'firefox'],
    mobile: true,
    performance: true,
  },
  performance: {
    load: true,
    stress: true,
    spike: false,
  },
};
```

#### 测试配置示例

```typescript
// jest.config.ts
import type { Config } from '@jest/types';

const config: Config.InitialOptions = {
  // 项目根目录
  rootDir: '.',
  
  // 测试环境
  testEnvironment: 'node',
  
  // 测试文件匹配模式
  testMatch: [
    '<rootDir>/src/**/__tests__/**/*.{js,jsx,ts,tsx}',
    '<rootDir>/src/**/*.{test,spec}.{js,jsx,ts,tsx}',
  ],
  
  // 覆盖率收集
  collectCoverageFrom: [
    'src/**/*.{js,jsx,ts,tsx}',
    '!src/**/*.d.ts',
    '!src/**/__tests__/**',
    '!src/**/__mocks__/**',
  ],
  
  // 覆盖率阈值
  coverageThreshold: {
    global: {
      branches: 80,
      functions: 80,
      lines: 80,
      statements: 80,
    },
  },
  
  // 测试设置文件
  setupFilesAfterEnv: ['<rootDir>/test/setup.ts'],
  
  // 模块路径映射
  moduleNameMapping: {
    '^@/(.*)$': '<rootDir>/src/$1',
    '^@test/(.*)$': '<rootDir>/test/$1',
  },
  
  // 转换器
  transform: {
    '^.+\\.(ts|tsx)$': 'ts-jest',
  },
  
  // 模块文件扩展名
  moduleFileExtensions: ['ts', 'tsx', 'js', 'jsx', 'json'],
  
  // 测试超时时间
  testTimeout: 10000,
  
  // 并行执行
  maxWorkers: '50%',
  
  // 详细输出
  verbose: true,
  
  // 测试报告
  reporters: [
    'default',
    [
      'jest-junit',
      {
        outputDirectory: 'reports/junit',
        outputName: 'js-test-results.xml',
        classNameTemplate: '{classname}-{title}',
        titleTemplate: '{classname}-{title}',
        ancestorSeparator: ' › ',
        usePathForSuiteName: true,
      },
    ],
  ],
};

export default config;
```

### 2.3 部署策略

#### 蓝绿部署策略

```mermaid
graph LR
    subgraph "蓝绿部署流程"
        A1[当前版本 - 蓝色] --> B1[用户流量]
        A2[新版本 - 绿色] --> B2[测试流量]
        B1 --> C1[健康检查]
        B2 --> C2[功能验证]
        C1 --> D1[切换流量]
        C2 --> D1
        D1 --> E1[蓝色版本下线]
    end
    
    classDef blue fill:#e3f2fd,stroke:#1565c0,stroke-width:2px,color:#0d47a1
    classDef green fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px,color:#1b5e20
    classDef process fill:#f3e5f5,stroke:#6a1b9a,stroke-width:2px,color:#4a148c
    
    class A1 blue
    class A2 green
    class B1,B2,C1,C2,D1,E1 process
```

#### Kubernetes部署配置

```yaml
# k8s/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: iam-api
  namespace: iam-system
  labels:
    app: iam-api
    version: v1.0.0
spec:
  replicas: 3
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 1
      maxUnavailable: 0
  selector:
    matchLabels:
      app: iam-api
  template:
    metadata:
      labels:
        app: iam-api
        version: v1.0.0
    spec:
      containers:
      - name: iam-api
        image: ghcr.io/your-org/iam-api:latest
        ports:
        - containerPort: 3000
        env:
        - name: NODE_ENV
          value: "production"
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: iam-secrets
              key: database-url
        - name: REDIS_URL
          valueFrom:
            secretKeyRef:
              name: iam-secrets
              key: redis-url
        - name: JWT_SECRET
          valueFrom:
            secretKeyRef:
              name: iam-secrets
              key: jwt-secret
        resources:
          requests:
            memory: "512Mi"
            cpu: "250m"
          limits:
            memory: "1Gi"
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /health
            port: 3000
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /ready
            port: 3000
          initialDelaySeconds: 5
          periodSeconds: 5
        securityContext:
          runAsNonRoot: true
          runAsUser: 1001
          allowPrivilegeEscalation: false
          readOnlyRootFilesystem: true
          capabilities:
            drop:
            - ALL
      imagePullSecrets:
      - name: ghcr-secret
      securityContext:
        fsGroup: 1001
```

### 2.4 回滚机制

#### 自动回滚策略

```typescript
// deployment/rollback.service.ts
import { Injectable, Logger } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';

export interface RollbackConfig {
  // 健康检查配置
  healthCheck: {
    endpoint: string;
    timeout: number;
    interval: number;
    retries: number;
  };
  
  // 回滚触发条件
  triggers: {
    errorRate: number; // 错误率阈值
    responseTime: number; // 响应时间阈值
    cpuUsage: number; // CPU使用率阈值
    memoryUsage: number; // 内存使用率阈值
  };
  
  // 回滚策略
  strategy: {
    automatic: boolean; // 是否自动回滚
    manualApproval: boolean; // 是否需要人工审批
    rollbackWindow: number; // 回滚窗口时间（分钟）
  };
}

@Injectable()
export class RollbackService {
  private readonly logger = new Logger(RollbackService.name);
  private readonly config: RollbackConfig;

  constructor(private configService: ConfigService) {
    this.config = {
      healthCheck: {
        endpoint: '/health',
        timeout: 5000,
        interval: 30000,
        retries: 3,
      },
      triggers: {
        errorRate: 0.05, // 5%错误率
        responseTime: 2000, // 2秒响应时间
        cpuUsage: 0.8, // 80% CPU使用率
        memoryUsage: 0.85, // 85% 内存使用率
      },
      strategy: {
        automatic: true,
        manualApproval: false,
        rollbackWindow: 30, // 30分钟
      },
    };
  }

  /**
   * 检查部署健康状态
   */
  async checkDeploymentHealth(): Promise<boolean> {
    try {
      const response = await fetch(this.config.healthCheck.endpoint, {
        method: 'GET',
        timeout: this.config.healthCheck.timeout,
      });
      
      return response.ok;
    } catch (error) {
      this.logger.error('Health check failed', error);
      return false;
    }
  }

  /**
   * 检查性能指标
   */
  async checkPerformanceMetrics(): Promise<{
    errorRate: number;
    responseTime: number;
    cpuUsage: number;
    memoryUsage: number;
  }> {
    // 这里集成具体的监控系统API
    // 例如：Prometheus、DataDog、New Relic等
    return {
      errorRate: 0.02,
      responseTime: 1500,
      cpuUsage: 0.6,
      memoryUsage: 0.7,
    };
  }

  /**
   * 执行回滚操作
   */
  async executeRollback(reason: string): Promise<void> {
    this.logger.warn(`Initiating rollback: ${reason}`);
    
    try {
      // 1. 通知运维团队
      await this.notifyOperations(reason);
      
      // 2. 执行回滚命令
      await this.rollbackDeployment();
      
      // 3. 验证回滚结果
      const isHealthy = await this.verifyRollback();
      
      if (isHealthy) {
        this.logger.log('Rollback completed successfully');
        await this.notifyRollbackSuccess();
      } else {
        this.logger.error('Rollback verification failed');
        await this.notifyRollbackFailure();
      }
    } catch (error) {
      this.logger.error('Rollback execution failed', error);
      await this.notifyRollbackFailure();
      throw error;
    }
  }

  /**
   * 监控部署状态
   */
  async monitorDeployment(): Promise<void> {
    setInterval(async () => {
      const health = await this.checkDeploymentHealth();
      const metrics = await this.checkPerformanceMetrics();
      
      // 检查是否需要回滚
      if (!health || this.shouldRollback(metrics)) {
        const reason = this.getRollbackReason(health, metrics);
        await this.executeRollback(reason);
      }
    }, this.config.healthCheck.interval);
  }

  private shouldRollback(metrics: any): boolean {
    return (
      metrics.errorRate > this.config.triggers.errorRate ||
      metrics.responseTime > this.config.triggers.responseTime ||
      metrics.cpuUsage > this.config.triggers.cpuUsage ||
      metrics.memoryUsage > this.config.triggers.memoryUsage
    );
  }

  private getRollbackReason(health: boolean, metrics: any): string {
    if (!health) return 'Health check failed';
    if (metrics.errorRate > this.config.triggers.errorRate) return 'High error rate';
    if (metrics.responseTime > this.config.triggers.responseTime) return 'High response time';
    if (metrics.cpuUsage > this.config.triggers.cpuUsage) return 'High CPU usage';
    if (metrics.memoryUsage > this.config.triggers.memoryUsage) return 'High memory usage';
    return 'Unknown reason';
  }

  private async notifyOperations(reason: string): Promise<void> {
    // 发送通知到运维团队
    // 可以通过Slack、邮件、短信等方式
  }

  private async rollbackDeployment(): Promise<void> {
    // 执行具体的回滚命令
    // 例如：kubectl rollout undo deployment/iam-api
  }

  private async verifyRollback(): Promise<boolean> {
    // 验证回滚后的服务状态
    return await this.checkDeploymentHealth();
  }

  private async notifyRollbackSuccess(): Promise<void> {
    // 通知回滚成功
  }

  private async notifyRollbackFailure(): Promise<void> {
    // 通知回滚失败
  }
}
```

---