# 07-部署与运维设计之6


## 6. 性能优化策略

### 6.1 应用性能优化

#### 6.1.1 代码层面优化

**查询优化策略**

```typescript
// performance/query-optimization.service.ts
import { Injectable, Logger } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { User } from '../domain/entities/user.entity';

@Injectable()
export class QueryOptimizationService {
  private readonly logger = new Logger(QueryOptimizationService.name);

  constructor(
    @InjectRepository(User)
    private userRepository: Repository<User>,
  ) {}

  /**
   * 优化用户查询 - 使用索引
   */
  async getUsersByTenantOptimized(tenantId: string): Promise<User[]> {
    // 使用索引优化的查询
    return await this.userRepository
      .createQueryBuilder('user')
      .leftJoinAndSelect('user.roles', 'roles')
      .leftJoinAndSelect('user.permissions', 'permissions')
      .where('user.tenantId = :tenantId', { tenantId })
      .andWhere('user.isActive = :isActive', { isActive: true })
      .orderBy('user.createdAt', 'DESC')
      .cache(true) // 启用查询缓存
      .getMany();
  }

  /**
   * 分页查询优化
   */
  async getUsersPaginated(
    tenantId: string,
    page: number = 1,
    limit: number = 20
  ): Promise<{ users: User[]; total: number }> {
    const skip = (page - 1) * limit;

    const [users, total] = await this.userRepository
      .createQueryBuilder('user')
      .select([
        'user.id',
        'user.email',
        'user.firstName',
        'user.lastName',
        'user.isActive',
        'user.createdAt',
      ]) // 只选择需要的字段
      .where('user.tenantId = :tenantId', { tenantId })
      .skip(skip)
      .take(limit)
      .cache(true)
      .getManyAndCount();

    return { users, total };
  }
}
```

**缓存优化策略**

```typescript
// performance/cache-optimization.service.ts
import { Injectable, Logger } from '@nestjs/common';
import { RedisService } from '../shared/infrastructure/redis/redis.service';

export interface CacheConfig {
  ttl: number;
  maxSize: number;
  strategy: 'lru' | 'lfu' | 'fifo';
}

@Injectable()
export class CacheOptimizationService {
  private readonly logger = new Logger(CacheOptimizationService.name);
  private readonly memoryCache = new Map<string, { value: any; timestamp: number; ttl: number }>();

  constructor(private redisService: RedisService) {}

  /**
   * 多级缓存策略
   */
  async getWithMultiLevelCache<T>(
    key: string,
    fetchFunction: () => Promise<T>,
    config: CacheConfig
  ): Promise<T> {
    // 1. 检查内存缓存
    const memoryResult = this.getFromMemoryCache<T>(key);
    if (memoryResult) {
      return memoryResult;
    }

    // 2. 检查Redis缓存
    const redisResult = await this.getFromRedisCache<T>(key);
    if (redisResult) {
      // 回填到内存缓存
      this.setMemoryCache(key, redisResult, config.ttl);
      return redisResult;
    }

    // 3. 从数据源获取
    const data = await fetchFunction();
    
    // 4. 存储到缓存
    await this.setRedisCache(key, data, config.ttl);
    this.setMemoryCache(key, data, config.ttl);

    return data;
  }

  /**
   * 内存缓存操作
   */
  private getFromMemoryCache<T>(key: string): T | null {
    const item = this.memoryCache.get(key);
    if (!item) return null;

    // 检查是否过期
    if (Date.now() - item.timestamp > item.ttl * 1000) {
      this.memoryCache.delete(key);
      return null;
    }

    return item.value;
  }

  private setMemoryCache<T>(key: string, value: T, ttl: number): void {
    // 检查缓存大小限制
    if (this.memoryCache.size >= 1000) {
      // 简单的LRU实现
      const firstKey = this.memoryCache.keys().next().value;
      this.memoryCache.delete(firstKey);
    }

    this.memoryCache.set(key, {
      value,
      timestamp: Date.now(),
      ttl,
    });
  }

  /**
   * Redis缓存操作
   */
  private async getFromRedisCache<T>(key: string): Promise<T | null> {
    try {
      const data = await this.redisService.get(key);
      return data ? JSON.parse(data) : null;
    } catch (error) {
      this.logger.error('Redis cache get error', error);
      return null;
    }
  }

  private async setRedisCache<T>(key: string, value: T, ttl: number): Promise<void> {
    try {
      await this.redisService.set(key, JSON.stringify(value), ttl);
    } catch (error) {
      this.logger.error('Redis cache set error', error);
    }
  }

  /**
   * 缓存预热策略
   */
  async warmupCache(keys: string[], fetchFunction: (key: string) => Promise<any>): Promise<void> {
    this.logger.log(`Starting cache warmup for ${keys.length} keys`);

    const promises = keys.map(async (key) => {
      try {
        const data = await fetchFunction(key);
        await this.setRedisCache(key, data, 3600); // 1小时TTL
        this.logger.debug(`Warmed up cache for key: ${key}`);
      } catch (error) {
        this.logger.error(`Failed to warm up cache for key: ${key}`, error);
      }
    });

    await Promise.allSettled(promises);
    this.logger.log('Cache warmup completed');
  }

  /**
   * 缓存失效策略
   */
  async invalidateCache(pattern: string): Promise<void> {
    try {
      const keys = await this.redisService.keys(pattern);
      if (keys.length > 0) {
        await this.redisService.del(...keys);
        this.logger.log(`Invalidated ${keys.length} cache keys matching pattern: ${pattern}`);
      }
    } catch (error) {
      this.logger.error('Cache invalidation error', error);
    }
  }
}
```

**异步处理优化**

```typescript
// performance/async-optimization.service.ts
import { Injectable, Logger } from '@nestjs/common';
import { EventEmitter2 } from '@nestjs/event-emitter';

export interface AsyncTask {
  id: string;
  type: 'email' | 'notification' | 'report' | 'cleanup';
  priority: 'low' | 'normal' | 'high' | 'urgent';
  data: any;
  retries: number;
  maxRetries: number;
}

@Injectable()
export class AsyncOptimizationService {
  private readonly logger = new Logger(AsyncOptimizationService.name);
  private readonly taskQueue: AsyncTask[] = [];
  private readonly processingTasks = new Map<string, AsyncTask>();
  private isProcessing = false;

  constructor(private eventEmitter: EventEmitter2) {}

  /**
   * 添加异步任务到队列
   */
  addTask(task: Omit<AsyncTask, 'id' | 'retries'>): string {
    const taskWithId: AsyncTask = {
      ...task,
      id: this.generateTaskId(),
      retries: 0,
    };

    // 根据优先级插入队列
    this.insertTaskByPriority(taskWithId);
    
    this.logger.debug(`Added task ${taskWithId.id} to queue`);
    
    // 启动处理
    this.processQueue();

    return taskWithId.id;
  }

  /**
   * 处理任务队列
   */
  private async processQueue(): Promise<void> {
    if (this.isProcessing || this.taskQueue.length === 0) {
      return;
    }

    this.isProcessing = true;

    while (this.taskQueue.length > 0) {
      const task = this.taskQueue.shift();
      if (!task) continue;

      this.processingTasks.set(task.id, task);

      try {
        await this.executeTask(task);
        this.processingTasks.delete(task.id);
      } catch (error) {
        this.logger.error(`Task ${task.id} failed`, error);
        await this.handleTaskFailure(task);
      }
    }

    this.isProcessing = false;
  }

  /**
   * 执行任务
   */
  private async executeTask(task: AsyncTask): Promise<void> {
    this.logger.debug(`Executing task ${task.id} of type ${task.type}`);

    switch (task.type) {
      case 'email':
        await this.sendEmail(task.data);
        break;
      case 'notification':
        await this.sendNotification(task.data);
        break;
      case 'report':
        await this.generateReport(task.data);
        break;
      case 'cleanup':
        await this.performCleanup(task.data);
        break;
      default:
        throw new Error(`Unknown task type: ${task.type}`);
    }

    this.logger.debug(`Task ${task.id} completed successfully`);
  }

  /**
   * 处理任务失败
   */
  private async handleTaskFailure(task: AsyncTask): Promise<void> {
    task.retries++;

    if (task.retries < task.maxRetries) {
      // 重新加入队列，延迟重试
      const delay = Math.pow(2, task.retries) * 1000; // 指数退避
      setTimeout(() => {
        this.insertTaskByPriority(task);
        this.processQueue();
      }, delay);

      this.logger.warn(`Task ${task.id} will be retried (${task.retries}/${task.maxRetries})`);
    } else {
      // 任务最终失败
      this.logger.error(`Task ${task.id} failed permanently after ${task.retries} retries`);
      this.processingTasks.delete(task.id);
      
      // 发送失败事件
      this.eventEmitter.emit('task.failed', { taskId: task.id, task });
    }
  }

  /**
   * 根据优先级插入任务
   */
  private insertTaskByPriority(task: AsyncTask): void {
    const priorities = { urgent: 0, high: 1, normal: 2, low: 3 };
    const taskPriority = priorities[task.priority];

    let insertIndex = this.taskQueue.length;
    for (let i = 0; i < this.taskQueue.length; i++) {
      const currentPriority = priorities[this.taskQueue[i].priority];
      if (taskPriority < currentPriority) {
        insertIndex = i;
        break;
      }
    }

    this.taskQueue.splice(insertIndex, 0, task);
  }

  /**
   * 生成任务ID
   */
  private generateTaskId(): string {
    return `task_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  // 具体的任务执行方法
  private async sendEmail(data: any): Promise<void> {
    // 发送邮件的具体实现
    await new Promise(resolve => setTimeout(resolve, 100));
  }

  private async sendNotification(data: any): Promise<void> {
    // 发送通知的具体实现
    await new Promise(resolve => setTimeout(resolve, 50));
  }

  private async generateReport(data: any): Promise<void> {
    // 生成报告的具体实现
    await new Promise(resolve => setTimeout(resolve, 200));
  }

  private async performCleanup(data: any): Promise<void> {
    // 执行清理的具体实现
    await new Promise(resolve => setTimeout(resolve, 150));
  }

  /**
   * 获取队列状态
   */
  getQueueStatus(): {
    queueLength: number;
    processingCount: number;
    isProcessing: boolean;
  } {
    return {
      queueLength: this.taskQueue.length,
      processingCount: this.processingTasks.size,
      isProcessing: this.isProcessing,
    };
  }
}
```

---

### 6.2 数据库性能优化

#### 6.2.1 索引优化策略

**索引设计原则**

```typescript
// performance/database-index-optimization.service.ts
import { Injectable, Logger } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { User } from '../domain/entities/user.entity';

@Injectable()
export class DatabaseIndexOptimizationService {
  private readonly logger = new Logger(DatabaseIndexOptimizationService.name);

  constructor(
    @InjectRepository(User)
    private userRepository: Repository<User>,
  ) {}

  /**
   * 分析查询性能并推荐索引
   */
  async analyzeQueryPerformance(): Promise<{
    slowQueries: Array<{
      query: string;
      executionTime: number;
      frequency: number;
      recommendedIndexes: string[];
    }>;
    indexUsage: Array<{
      indexName: string;
      usageCount: number;
      efficiency: number;
    }>;
  }> {
    // 这里应该连接到数据库执行分析查询
    const slowQueries = await this.getSlowQueries();
    const indexUsage = await this.getIndexUsage();

    return {
      slowQueries,
      indexUsage,
    };
  }

  /**
   * 创建复合索引
   */
  async createCompositeIndex(
    tableName: string,
    columns: string[],
    indexName: string
  ): Promise<void> {
    const columnsList = columns.join(', ');
    const query = `CREATE INDEX ${indexName} ON ${tableName} (${columnsList})`;
    
    try {
      await this.userRepository.query(query);
      this.logger.log(`Created composite index: ${indexName}`);
    } catch (error) {
      this.logger.error(`Failed to create index: ${indexName}`, error);
      throw error;
    }
  }

  /**
   * 创建部分索引
   */
  async createPartialIndex(
    tableName: string,
    column: string,
    condition: string,
    indexName: string
  ): Promise<void> {
    const query = `CREATE INDEX ${indexName} ON ${tableName} (${column}) WHERE ${condition}`;
    
    try {
      await this.userRepository.query(query);
      this.logger.log(`Created partial index: ${indexName}`);
    } catch (error) {
      this.logger.error(`Failed to create partial index: ${indexName}`, error);
      throw error;
    }
  }

  /**
   * 优化现有索引
   */
  async optimizeIndexes(): Promise<{
    optimized: string[];
    removed: string[];
    added: string[];
  }> {
    const result = {
      optimized: [] as string[],
      removed: [] as string[],
      added: [] as string[],
    };

    // 分析未使用的索引
    const unusedIndexes = await this.getUnusedIndexes();
    for (const index of unusedIndexes) {
      try {
        await this.userRepository.query(`DROP INDEX ${index.name}`);
        result.removed.push(index.name);
        this.logger.log(`Removed unused index: ${index.name}`);
      } catch (error) {
        this.logger.error(`Failed to remove index: ${index.name}`, error);
      }
    }

    // 分析缺失的索引
    const missingIndexes = await this.getMissingIndexes();
    for (const index of missingIndexes) {
      try {
        await this.createCompositeIndex(index.table, index.columns, index.name);
        result.added.push(index.name);
      } catch (error) {
        this.logger.error(`Failed to add missing index: ${index.name}`, error);
      }
    }

    return result;
  }

  private async getSlowQueries(): Promise<any[]> {
    // 模拟获取慢查询
    return [
      {
        query: 'SELECT * FROM users WHERE tenant_id = ? AND is_active = ?',
        executionTime: 1500,
        frequency: 1000,
        recommendedIndexes: ['idx_users_tenant_active'],
      },
    ];
  }

  private async getIndexUsage(): Promise<any[]> {
    // 模拟获取索引使用情况
    return [
      {
        indexName: 'idx_users_email',
        usageCount: 5000,
        efficiency: 0.95,
      },
    ];
  }

  private async getUnusedIndexes(): Promise<any[]> {
    // 模拟获取未使用的索引
    return [
      {
        name: 'idx_users_old_field',
        table: 'users',
      },
    ];
  }

  private async getMissingIndexes(): Promise<any[]> {
    // 模拟获取缺失的索引
    return [
      {
        name: 'idx_users_tenant_active',
        table: 'users',
        columns: ['tenant_id', 'is_active'],
      },
    ];
  }
}
```

**查询优化建议**

```typescript
// performance/query-optimization-advisor.service.ts
import { Injectable, Logger } from '@nestjs/common';

export interface QueryOptimizationAdvice {
  queryId: string;
  originalQuery: string;
  optimizedQuery: string;
  performanceImprovement: number;
  recommendations: string[];
  estimatedSavings: {
    executionTime: number;
    cpuUsage: number;
    memoryUsage: number;
  };
}

@Injectable()
export class QueryOptimizationAdvisorService {
  private readonly logger = new Logger(QueryOptimizationAdvisorService.name);

  /**
   * 分析查询并提供优化建议
   */
  async analyzeQuery(query: string): Promise<QueryOptimizationAdvice> {
    const analysis = await this.performQueryAnalysis(query);
    const optimization = await this.generateOptimization(query, analysis);
    
    return {
      queryId: this.generateQueryId(query),
      originalQuery: query,
      optimizedQuery: optimization.optimizedQuery,
      performanceImprovement: optimization.improvement,
      recommendations: optimization.recommendations,
      estimatedSavings: optimization.savings,
    };
  }

  /**
   * 执行查询分析
   */
  private async performQueryAnalysis(query: string): Promise<any> {
    // 这里应该执行实际的查询分析
    // 包括执行计划分析、性能统计等
    
    return {
      executionPlan: 'EXPLAIN ANALYZE ' + query,
      statistics: {
        rowsScanned: 10000,
        rowsReturned: 100,
        executionTime: 1500,
        cpuUsage: 0.8,
        memoryUsage: 0.6,
      },
      bottlenecks: [
        'Full table scan detected',
        'Missing index on WHERE clause',
        'Inefficient JOIN operation',
      ],
    };
  }

  /**
   * 生成优化建议
   */
  private async generateOptimization(
    originalQuery: string,
    analysis: any
  ): Promise<{
    optimizedQuery: string;
    improvement: number;
    recommendations: string[];
    savings: any;
  }> {
    const recommendations: string[] = [];
    let optimizedQuery = originalQuery;
    let improvement = 0;

    // 基于分析结果生成优化建议
    if (analysis.bottlenecks.includes('Full table scan detected')) {
      recommendations.push('Add appropriate indexes to reduce table scans');
      improvement += 0.6;
    }

    if (analysis.bottlenecks.includes('Missing index on WHERE clause')) {
      recommendations.push('Create index on WHERE clause columns');
      improvement += 0.3;
    }

    if (analysis.bottlenecks.includes('Inefficient JOIN operation')) {
      recommendations.push('Optimize JOIN operations with proper indexes');
      improvement += 0.4;
    }

    // 生成优化后的查询
    optimizedQuery = this.applyOptimizations(originalQuery, recommendations);

    return {
      optimizedQuery,
      improvement: Math.min(improvement, 0.9), // 最大90%改进
      recommendations,
      savings: {
        executionTime: analysis.statistics.executionTime * (1 - improvement),
        cpuUsage: analysis.statistics.cpuUsage * (1 - improvement),
        memoryUsage: analysis.statistics.memoryUsage * (1 - improvement),
      },
    };
  }

  /**
   * 应用优化
   */
  private applyOptimizations(query: string, recommendations: string[]): string {
    // 这里应该实现具体的查询优化逻辑
    let optimizedQuery = query;

    // 示例：添加LIMIT子句
    if (!optimizedQuery.includes('LIMIT')) {
      optimizedQuery += ' LIMIT 1000';
    }

    // 示例：优化SELECT子句
    if (optimizedQuery.includes('SELECT *')) {
      optimizedQuery = optimizedQuery.replace('SELECT *', 'SELECT id, name, email');
    }

    return optimizedQuery;
  }

  /**
   * 生成查询ID
   */
  private generateQueryId(query: string): string {
    return `query_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }
}
```

#### 6.2.2 连接池优化

**连接池配置优化**

```typescript
// performance/connection-pool-optimization.service.ts
import { Injectable, Logger } from '@nestjs/common';
import { DataSource } from 'typeorm';

export interface ConnectionPoolConfig {
  max: number;
  min: number;
  acquireTimeoutMillis: number;
  createTimeoutMillis: number;
  destroyTimeoutMillis: number;
  idleTimeoutMillis: number;
  reapIntervalMillis: number;
  createRetryIntervalMillis: number;
}

export interface PoolMetrics {
  totalConnections: number;
  activeConnections: number;
  idleConnections: number;
  waitingConnections: number;
  maxConnections: number;
  minConnections: number;
  connectionTimeout: number;
  acquireTimeout: number;
}

@Injectable()
export class ConnectionPoolOptimizationService {
  private readonly logger = new Logger(ConnectionPoolOptimizationService.name);

  /**
   * 获取生产环境连接池配置
   */
  getProductionPoolConfig(): ConnectionPoolConfig {
    return {
      max: 20,
      min: 5,
      acquireTimeoutMillis: 30000,
      createTimeoutMillis: 30000,
      destroyTimeoutMillis: 5000,
      idleTimeoutMillis: 30000,
      reapIntervalMillis: 1000,
      createRetryIntervalMillis: 200,
    };
  }

  /**
   * 获取开发环境连接池配置
   */
  getDevelopmentPoolConfig(): ConnectionPoolConfig {
    return {
      max: 10,
      min: 2,
      acquireTimeoutMillis: 10000,
      createTimeoutMillis: 10000,
      destroyTimeoutMillis: 2000,
      idleTimeoutMillis: 10000,
      reapIntervalMillis: 1000,
      createRetryIntervalMillis: 100,
    };
  }

  /**
   * 根据负载动态调整连接池配置
   */
  getDynamicPoolConfig(currentLoad: number): ConnectionPoolConfig {
    const baseConfig = this.getProductionPoolConfig();
    
    if (currentLoad > 0.8) {
      // 高负载时增加连接数
      return {
        ...baseConfig,
        max: Math.min(baseConfig.max * 1.5, 50),
        min: Math.min(baseConfig.min * 1.5, 10),
      };
    } else if (currentLoad < 0.3) {
      // 低负载时减少连接数
      return {
        ...baseConfig,
        max: Math.max(baseConfig.max * 0.8, 10),
        min: Math.max(baseConfig.min * 0.8, 2),
      };
    }
    
    return baseConfig;
  }

  /**
   * 验证连接池配置
   */
  validatePoolConfig(config: ConnectionPoolConfig): {
    isValid: boolean;
    errors: string[];
  } {
    const errors: string[] = [];

    if (config.max < config.min) {
      errors.push('Max connections cannot be less than min connections');
    }

    if (config.max > 100) {
      errors.push('Max connections should not exceed 100');
    }

    if (config.min < 1) {
      errors.push('Min connections should be at least 1');
    }

    if (config.acquireTimeoutMillis < 1000) {
      errors.push('Acquire timeout should be at least 1000ms');
    }

    if (config.idleTimeoutMillis < 5000) {
      errors.push('Idle timeout should be at least 5000ms');
    }

    return {
      isValid: errors.length === 0,
      errors,
    };
  }

  /**
   * 监控连接池性能
   */
  async monitorPoolPerformance(dataSource: DataSource): Promise<PoolMetrics> {
    const driver = dataSource.driver as any;
    const pool = driver.pool;

    if (!pool) {
      throw new Error('Connection pool not available');
    }

    return {
      totalConnections: pool.totalCount || 0,
      activeConnections: pool.usedCount || 0,
      idleConnections: pool.freeCount || 0,
      waitingConnections: pool.pendingCount || 0,
      maxConnections: pool.max || 0,
      minConnections: pool.min || 0,
      connectionTimeout: pool.acquireTimeoutMillis || 0,
      acquireTimeout: pool.createTimeoutMillis || 0,
    };
  }

  /**
   * 检查连接池健康状态
   */
  async checkPoolHealth(dataSource: DataSource): Promise<{
    isHealthy: boolean;
    issues: string[];
    recommendations: string[];
  }> {
    const metrics = await this.monitorPoolPerformance(dataSource);
    const issues: string[] = [];
    const recommendations: string[] = [];

    // 检查连接池使用率
    const usageRate = metrics.activeConnections / metrics.maxConnections;
    if (usageRate > 0.8) {
      issues.push(`High connection pool usage: ${(usageRate * 100).toFixed(1)}%`);
      recommendations.push('Consider increasing max connections or optimizing queries');
    }

    // 检查等待连接数
    if (metrics.waitingConnections > 0) {
      issues.push(`Connections waiting: ${metrics.waitingConnections}`);
      recommendations.push('Consider increasing pool size or optimizing slow queries');
    }

    // 检查空闲连接数
    const idleRate = metrics.idleConnections / metrics.maxConnections;
    if (idleRate > 0.7) {
      issues.push(`High idle connections: ${metrics.idleConnections}`);
      recommendations.push('Consider reducing min connections to save resources');
    }

    return {
      isHealthy: issues.length === 0,
      issues,
      recommendations,
    };
  }
}

```
### 6.3 缓存性能优化

#### 6.3.1 缓存策略优化

**多级缓存架构**

```typescript
// performance/cache-strategy-optimization.service.ts
import { Injectable, Logger } from '@nestjs/common';
import { RedisService } from '../shared/infrastructure/redis/redis.service';

export interface CacheLevel {
  name: string;
  type: 'memory' | 'redis' | 'database';
  ttl: number;
  maxSize: number;
  priority: number;
}

export interface CacheStrategy {
  levels: CacheLevel[];
  writePolicy: 'write-through' | 'write-behind' | 'write-around';
  readPolicy: 'cache-first' | 'cache-aside' | 'read-through';
  evictionPolicy: 'lru' | 'lfu' | 'fifo' | 'ttl';
}

@Injectable()
export class CacheStrategyOptimizationService {
  private readonly logger = new Logger(CacheStrategyOptimizationService.name);
  private readonly memoryCache = new Map<string, { value: any; timestamp: number; ttl: number }>();

  constructor(private redisService: RedisService) {}

  /**
   * 获取优化的缓存策略
   */
  getOptimizedCacheStrategy(): CacheStrategy {
    return {
      levels: [
        {
          name: 'L1-Memory',
          type: 'memory',
          ttl: 300, // 5分钟
          maxSize: 1000,
          priority: 1,
        },
        {
          name: 'L2-Redis',
          type: 'redis',
          ttl: 3600, // 1小时
          maxSize: 10000,
          priority: 2,
        },
        {
          name: 'L3-Database',
          type: 'database',
          ttl: 86400, // 24小时
          maxSize: 100000,
          priority: 3,
        },
      ],
      writePolicy: 'write-through',
      readPolicy: 'cache-first',
      evictionPolicy: 'lru',
    };
  }

  /**
   * 多级缓存读取
   */
  async getWithMultiLevelCache<T>(
    key: string,
    fetchFunction: () => Promise<T>,
    strategy: CacheStrategy
  ): Promise<T> {
    // 按优先级从高到低查找
    const sortedLevels = strategy.levels.sort((a, b) => a.priority - b.priority);

    for (const level of sortedLevels) {
      const value = await this.getFromCacheLevel<T>(key, level);
      if (value !== null) {
        // 回填到更高优先级的缓存
        await this.backfillToHigherLevels(key, value, level, strategy);
        return value;
      }
    }

    // 所有缓存都未命中，从数据源获取
    const data = await fetchFunction();
    
    // 写入所有缓存级别
    await this.writeToAllLevels(key, data, strategy);
    
    return data;
  }

  /**
   * 从指定缓存级别获取数据
   */
  private async getFromCacheLevel<T>(key: string, level: CacheLevel): Promise<T | null> {
    try {
      switch (level.type) {
        case 'memory':
          return this.getFromMemoryCache<T>(key);
        case 'redis':
          return await this.getFromRedisCache<T>(key);
        case 'database':
          return await this.getFromDatabaseCache<T>(key);
        default:
          return null;
      }
    } catch (error) {
      this.logger.error(`Failed to get from cache level ${level.name}`, error);
      return null;
    }
  }

  /**
   * 回填到更高优先级的缓存
   */
  private async backfillToHigherLevels<T>(
    key: string,
    value: T,
    sourceLevel: CacheLevel,
    strategy: CacheStrategy
  ): Promise<void> {
    const higherLevels = strategy.levels.filter(level => level.priority < sourceLevel.priority);
    
    for (const level of higherLevels) {
      try {
        await this.writeToCacheLevel(key, value, level);
      } catch (error) {
        this.logger.error(`Failed to backfill to level ${level.name}`, error);
      }
    }
  }

  /**
   * 写入所有缓存级别
   */
  private async writeToAllLevels<T>(key: string, value: T, strategy: CacheStrategy): Promise<void> {
    const promises = strategy.levels.map(level => this.writeToCacheLevel(key, value, level));
    await Promise.allSettled(promises);
  }

  /**
   * 写入指定缓存级别
   */
  private async writeToCacheLevel<T>(key: string, value: T, level: CacheLevel): Promise<void> {
    try {
      switch (level.type) {
        case 'memory':
          this.setMemoryCache(key, value, level.ttl);
          break;
        case 'redis':
          await this.setRedisCache(key, value, level.ttl);
          break;
        case 'database':
          await this.setDatabaseCache(key, value, level.ttl);
          break;
      }
    } catch (error) {
      this.logger.error(`Failed to write to cache level ${level.name}`, error);
    }
  }

  // 内存缓存操作
  private getFromMemoryCache<T>(key: string): T | null {
    const item = this.memoryCache.get(key);
    if (!item) return null;

    if (Date.now() - item.timestamp > item.ttl * 1000) {
      this.memoryCache.delete(key);
      return null;
    }

    return item.value;
  }

  private setMemoryCache<T>(key: string, value: T, ttl: number): void {
    if (this.memoryCache.size >= 1000) {
      const firstKey = this.memoryCache.keys().next().value;
      this.memoryCache.delete(firstKey);
    }

    this.memoryCache.set(key, {
      value,
      timestamp: Date.now(),
      ttl,
    });
  }

  // Redis缓存操作
  private async getFromRedisCache<T>(key: string): Promise<T | null> {
    try {
      const data = await this.redisService.get(key);
      return data ? JSON.parse(data) : null;
    } catch (error) {
      this.logger.error('Redis cache get error', error);
      return null;
    }
  }

  private async setRedisCache<T>(key: string, value: T, ttl: number): Promise<void> {
    try {
      await this.redisService.set(key, JSON.stringify(value), ttl);
    } catch (error) {
      this.logger.error('Redis cache set error', error);
    }
  }

  // 数据库缓存操作
  private async getFromDatabaseCache<T>(key: string): Promise<T | null> {
    // 这里应该实现从数据库缓存表读取数据
    return null;
  }

  private async setDatabaseCache<T>(key: string, value: T, ttl: number): Promise<void> {
    // 这里应该实现向数据库缓存表写入数据
  }
}
```

#### 6.3.2 缓存预热和失效策略

**缓存预热服务**

```typescript
// performance/cache-warmup.service.ts
import { Injectable, Logger } from '@nestjs/common';
import { RedisService } from '../shared/infrastructure/redis/redis.service';

export interface WarmupConfig {
  batchSize: number;
  concurrency: number;
  retryAttempts: number;
  retryDelay: number;
  progressCallback?: (progress: number) => void;
}

export interface WarmupTask {
  id: string;
  key: string;
  fetchFunction: () => Promise<any>;
  priority: 'high' | 'normal' | 'low';
  status: 'pending' | 'processing' | 'completed' | 'failed';
  error?: string;
}

@Injectable()
export class CacheWarmupService {
  private readonly logger = new Logger(CacheWarmupService.name);
  private readonly warmupTasks: Map<string, WarmupTask> = new Map();
  private isWarmingUp = false;

  constructor(private redisService: RedisService) {}

  /**
   * 添加预热任务
   */
  addWarmupTask(
    key: string,
    fetchFunction: () => Promise<any>,
    priority: 'high' | 'normal' | 'low' = 'normal'
  ): string {
    const taskId = this.generateTaskId();
    const task: WarmupTask = {
      id: taskId,
      key,
      fetchFunction,
      priority,
      status: 'pending',
    };

    this.warmupTasks.set(taskId, task);
    this.logger.debug(`Added warmup task: ${taskId} for key: ${key}`);

    return taskId;
  }

  /**
   * 执行缓存预热
   */
  async executeWarmup(config: WarmupConfig): Promise<{
    totalTasks: number;
    completedTasks: number;
    failedTasks: number;
    duration: number;
  }> {
    if (this.isWarmingUp) {
      throw new Error('Warmup is already in progress');
    }

    this.isWarmingUp = true;
    const startTime = Date.now();
    const tasks = Array.from(this.warmupTasks.values());

    // 按优先级排序
    const priorityOrder = { high: 0, normal: 1, low: 2 };
    tasks.sort((a, b) => priorityOrder[a.priority] - priorityOrder[b.priority]);

    let completedTasks = 0;
    let failedTasks = 0;

    try {
      // 分批处理任务
      for (let i = 0; i < tasks.length; i += config.batchSize) {
        const batch = tasks.slice(i, i + config.batchSize);
        
        // 并发执行批次任务
        const batchPromises = batch.map(task => this.executeWarmupTask(task, config));
        const results = await Promise.allSettled(batchPromises);

        // 统计结果
        for (const result of results) {
          if (result.status === 'fulfilled') {
            completedTasks++;
          } else {
            failedTasks++;
          }
        }

        // 更新进度
        const progress = ((i + batch.length) / tasks.length) * 100;
        if (config.progressCallback) {
          config.progressCallback(progress);
        }

        this.logger.log(`Warmup progress: ${progress.toFixed(1)}%`);
      }

      const duration = Date.now() - startTime;
      this.logger.log(`Cache warmup completed in ${duration}ms`);

      return {
        totalTasks: tasks.length,
        completedTasks,
        failedTasks,
        duration,
      };

    } finally {
      this.isWarmingUp = false;
    }
  }

  /**
   * 执行单个预热任务
   */
  private async executeWarmupTask(task: WarmupTask, config: WarmupConfig): Promise<void> {
    task.status = 'processing';

    for (let attempt = 1; attempt <= config.retryAttempts; attempt++) {
      try {
        const data = await task.fetchFunction();
        await this.redisService.set(task.key, JSON.stringify(data), 3600); // 1小时TTL
        
        task.status = 'completed';
        this.logger.debug(`Warmed up cache for key: ${task.key}`);
        return;

      } catch (error) {
        this.logger.error(`Warmup failed for key: ${task.key} (attempt ${attempt})`, error);
        
        if (attempt === config.retryAttempts) {
          task.status = 'failed';
          task.error = error.message;
          throw error;
        }

        // 等待后重试
        await new Promise(resolve => setTimeout(resolve, config.retryDelay));
      }
    }
  }

  /**
   * 智能预热策略
   */
  async intelligentWarmup(
    accessPatterns: Array<{ key: string; frequency: number; lastAccess: Date }>,
    config: WarmupConfig
  ): Promise<void> {
    this.logger.log('Starting intelligent cache warmup');

    // 按访问频率排序
    const sortedPatterns = accessPatterns.sort((a, b) => b.frequency - a.frequency);

    // 只预热高频访问的数据
    const highFrequencyPatterns = sortedPatterns.slice(0, 100); // 预热前100个高频数据

    for (const pattern of highFrequencyPatterns) {
      this.addWarmupTask(
        pattern.key,
        () => this.fetchDataForKey(pattern.key),
        pattern.frequency > 1000 ? 'high' : 'normal'
      );
    }

    await this.executeWarmup(config);
  }

  /**
   * 定时预热
   */
  startScheduledWarmup(
    schedule: 'hourly' | 'daily' | 'weekly',
    config: WarmupConfig
  ): void {
    const intervals = {
      hourly: 60 * 60 * 1000,
      daily: 24 * 60 * 60 * 1000,
      weekly: 7 * 24 * 60 * 60 * 1000,
    };

    const interval = intervals[schedule];

    setInterval(async () => {
      try {
        await this.executeWarmup(config);
        this.logger.log(`Scheduled warmup completed (${schedule})`);
      } catch (error) {
        this.logger.error(`Scheduled warmup failed (${schedule})`, error);
      }
    }, interval);

    this.logger.log(`Started scheduled warmup: ${schedule}`);
  }

  /**
   * 获取预热状态
   */
  getWarmupStatus(): {
    isWarmingUp: boolean;
    totalTasks: number;
    pendingTasks: number;
    completedTasks: number;
    failedTasks: number;
  } {
    const tasks = Array.from(this.warmupTasks.values());
    
    return {
      isWarmingUp: this.isWarmingUp,
      totalTasks: tasks.length,
      pendingTasks: tasks.filter(t => t.status === 'pending').length,
      completedTasks: tasks.filter(t => t.status === 'completed').length,
      failedTasks: tasks.filter(t => t.status === 'failed').length,
    };
  }

  /**
   * 清理预热任务
   */
  clearWarmupTasks(): void {
    this.warmupTasks.clear();
    this.logger.log('Cleared all warmup tasks');
  }

  private async fetchDataForKey(key: string): Promise<any> {
    // 这里应该实现根据key获取数据的逻辑
    // 例如：从数据库查询、调用外部API等
    return { key, data: 'sample data' };
  }

  private generateTaskId(): string {
    return `warmup_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }
}
```

**缓存失效策略**

```typescript
// performance/cache-invalidation.service.ts
import { Injectable, Logger } from '@nestjs/common';
import { RedisService } from '../shared/infrastructure/redis/redis.service';

export interface InvalidationStrategy {
  type: 'immediate' | 'delayed' | 'lazy';
  delay?: number;
  batchSize?: number;
  pattern?: string;
}

export interface InvalidationTask {
  id: string;
  keys: string[];
  strategy: InvalidationStrategy;
  status: 'pending' | 'processing' | 'completed' | 'failed';
  createdAt: Date;
  completedAt?: Date;
  error?: string;
}

@Injectable()
export class CacheInvalidationService {
  private readonly logger = new Logger(CacheInvalidationService.name);
  private readonly invalidationTasks: Map<string, InvalidationTask> = new Map();

  constructor(private redisService: RedisService) {}

  /**
   * 立即失效缓存
   */
  async invalidateImmediate(keys: string[]): Promise<{
    invalidated: number;
    failed: number;
  }> {
    this.logger.log(`Invalidating ${keys.length} keys immediately`);

    let invalidated = 0;
    let failed = 0;

    for (const key of keys) {
      try {
        await this.redisService.del(key);
        invalidated++;
      } catch (error) {
        this.logger.error(`Failed to invalidate key: ${key}`, error);
        failed++;
      }
    }

    this.logger.log(`Invalidation completed: ${invalidated} invalidated, ${failed} failed`);
    return { invalidated, failed };
  }

  /**
   * 延迟失效缓存
   */
  async invalidateDelayed(
    keys: string[],
    delay: number = 5000
  ): Promise<string> {
    const taskId = this.generateTaskId();
    const task: InvalidationTask = {
      id: taskId,
      keys,
      strategy: { type: 'delayed', delay },
      status: 'pending',
      createdAt: new Date(),
    };

    this.invalidationTasks.set(taskId, task);

    // 延迟执行失效
    setTimeout(async () => {
      try {
        task.status = 'processing';
        await this.invalidateImmediate(keys);
        task.status = 'completed';
        task.completedAt = new Date();
      } catch (error) {
        task.status = 'failed';
        task.error = error.message;
        this.logger.error(`Delayed invalidation failed for task: ${taskId}`, error);
      }
    }, delay);

    this.logger.log(`Scheduled delayed invalidation for ${keys.length} keys (${delay}ms delay)`);
    return taskId;
  }

  /**
   * 模式失效缓存
   */
  async invalidateByPattern(pattern: string): Promise<{
    invalidated: number;
    failed: number;
  }> {
    this.logger.log(`Invalidating keys matching pattern: ${pattern}`);

    try {
      const keys = await this.redisService.keys(pattern);
      
      if (keys.length === 0) {
        this.logger.log(`No keys found matching pattern: ${pattern}`);
        return { invalidated: 0, failed: 0 };
      }

      return await this.invalidateImmediate(keys);

    } catch (error) {
      this.logger.error(`Failed to invalidate by pattern: ${pattern}`, error);
      return { invalidated: 0, failed: 1 };
    }
  }

  /**
   * 批量失效缓存
   */
  async invalidateBatch(
    keys: string[],
    batchSize: number = 100
  ): Promise<{
    totalBatches: number;
    totalInvalidated: number;
    totalFailed: number;
  }> {
    this.logger.log(`Starting batch invalidation for ${keys.length} keys`);

    let totalInvalidated = 0;
    let totalFailed = 0;
    const totalBatches = Math.ceil(keys.length / batchSize);

    for (let i = 0; i < keys.length; i += batchSize) {
      const batch = keys.slice(i, i + batchSize);
      const result = await this.invalidateImmediate(batch);
      
      totalInvalidated += result.invalidated;
      totalFailed += result.failed;

      this.logger.log(`Batch ${Math.floor(i / batchSize) + 1}/${totalBatches} completed`);
    }

    this.logger.log(`Batch invalidation completed: ${totalInvalidated} invalidated, ${totalFailed} failed`);
    return { totalBatches, totalInvalidated, totalFailed };
  }

  /**
   * 智能失效策略
   */
  async intelligentInvalidation(
    dataChanges: Array<{ table: string; operation: 'insert' | 'update' | 'delete'; recordId?: string }>
  ): Promise<void> {
    this.logger.log('Starting intelligent cache invalidation');

    const invalidationRules = this.getInvalidationRules();
    const keysToInvalidate: string[] = [];

    for (const change of dataChanges) {
      const rules = invalidationRules[change.table] || [];
      
      for (const rule of rules) {
        if (this.shouldInvalidate(change, rule)) {
          const keys = this.generateKeysForRule(rule, change);
          keysToInvalidate.push(...keys);
        }
      }
    }

    if (keysToInvalidate.length > 0) {
      await this.invalidateImmediate(keysToInvalidate);
      this.logger.log(`Intelligent invalidation completed: ${keysToInvalidate.length} keys invalidated`);
    }
  }

  /**
   * 获取失效规则
   */
  private getInvalidationRules(): Record<string, any[]> {
    return {
      users: [
        { pattern: 'user:*', operations: ['insert', 'update', 'delete'] },
        { pattern: 'users:list:*', operations: ['insert', 'update', 'delete'] },
      ],
      roles: [
        { pattern: 'role:*', operations: ['insert', 'update', 'delete'] },
        { pattern: 'roles:list:*', operations: ['insert', 'update', 'delete'] },
      ],
      permissions: [
        { pattern: 'permission:*', operations: ['insert', 'update', 'delete'] },
        { pattern: 'permissions:list:*', operations: ['insert', 'update', 'delete'] },
      ],
    };
  }

  /**
   * 判断是否需要失效
   */
  private shouldInvalidate(change: any, rule: any): boolean {
    return rule.operations.includes(change.operation);
  }

  /**
   * 根据规则生成需要失效的键
   */
  private generateKeysForRule(rule: any, change: any): string[] {
    const keys: string[] = [];

    if (rule.pattern.includes('*')) {
      // 模式匹配，需要查询Redis获取匹配的键
      // 这里应该实现实际的键查询逻辑
      keys.push(rule.pattern.replace('*', change.recordId || ''));
    } else {
      keys.push(rule.pattern);
    }

    return keys;
  }

  /**
   * 获取失效任务状态
   */
  getInvalidationStatus(): {
    totalTasks: number;
    pendingTasks: number;
    processingTasks: number;
    completedTasks: number;
    failedTasks: number;
  } {
    const tasks = Array.from(this.invalidationTasks.values());
    
    return {
      totalTasks: tasks.length,
      pendingTasks: tasks.filter(t => t.status === 'pending').length,
      processingTasks: tasks.filter(t => t.status === 'processing').length,
      completedTasks: tasks.filter(t => t.status === 'completed').length,
      failedTasks: tasks.filter(t => t.status === 'failed').length,
    };
  }

  /**
   * 清理失效任务
   */
  clearInvalidationTasks(): void {
    this.invalidationTasks.clear();
    this.logger.log('Cleared all invalidation tasks');
  }

  private generateTaskId(): string {
    return `invalidation_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }
}
``` 

### 6.4 网络性能优化

#### 6.4.1 CDN优化策略

**CDN配置服务**

```typescript
// performance/cdn-optimization.service.ts
import { Injectable, Logger } from '@nestjs/common';

export interface CDNConfig {
  provider: 'cloudflare' | 'aws-cloudfront' | 'aliyun-cdn' | 'tencent-cdn';
  domain: string;
  regions: string[];
  cacheRules: CDNCacheRule[];
  sslEnabled: boolean;
  compressionEnabled: boolean;
}

export interface CDNCacheRule {
  pattern: string;
  ttl: number;
  headers: Record<string, string>;
  compression: boolean;
}

export interface CDNPerformanceMetrics {
  hitRate: number;
  responseTime: number;
  bandwidth: number;
  errorRate: number;
  regions: Array<{
    region: string;
    performance: number;
  }>;
}

@Injectable()
export class CDNOptimizationService {
  private readonly logger = new Logger(CDNOptimizationService.name);

  /**
   * 获取优化的CDN配置
   */
  getOptimizedCDNConfig(): CDNConfig {
    return {
      provider: 'cloudflare',
      domain: 'cdn.example.com',
      regions: ['us-east-1', 'eu-west-1', 'ap-southeast-1'],
      cacheRules: [
        {
          pattern: '*.js',
          ttl: 86400, // 24小时
          headers: {
            'Cache-Control': 'public, max-age=86400',
            'Content-Type': 'application/javascript',
          },
          compression: true,
        },
        {
          pattern: '*.css',
          ttl: 86400,
          headers: {
            'Cache-Control': 'public, max-age=86400',
            'Content-Type': 'text/css',
          },
          compression: true,
        },
        {
          pattern: '*.png',
          ttl: 604800, // 7天
          headers: {
            'Cache-Control': 'public, max-age=604800',
            'Content-Type': 'image/png',
          },
          compression: false,
        },
        {
          pattern: '*.jpg',
          ttl: 604800,
          headers: {
            'Cache-Control': 'public, max-age=604800',
            'Content-Type': 'image/jpeg',
          },
          compression: false,
        },
      ],
      sslEnabled: true,
      compressionEnabled: true,
    };
  }

  /**
   * 配置静态资源CDN
   */
  async configureStaticAssetsCDN(): Promise<void> {
    const config = this.getOptimizedCDNConfig();
    
    this.logger.log('Configuring static assets CDN');

    // 配置缓存规则
    for (const rule of config.cacheRules) {
      await this.applyCacheRule(rule);
    }

    // 启用压缩
    if (config.compressionEnabled) {
      await this.enableCompression();
    }

    // 配置SSL
    if (config.sslEnabled) {
      await this.configureSSL();
    }

    this.logger.log('Static assets CDN configuration completed');
  }

  /**
   * 应用缓存规则
   */
  private async applyCacheRule(rule: CDNCacheRule): Promise<void> {
    this.logger.log(`Applying cache rule for pattern: ${rule.pattern}`);
    
    // 这里应该调用CDN提供商的API来配置缓存规则
    // 例如：Cloudflare API, AWS CloudFront API等
    
    await new Promise(resolve => setTimeout(resolve, 100)); // 模拟API调用
  }

  /**
   * 启用压缩
   */
  private async enableCompression(): Promise<void> {
    this.logger.log('Enabling CDN compression');
    
    // 配置Gzip/Brotli压缩
    const compressionConfig = {
      gzip: true,
      brotli: true,
      minSize: 1024, // 最小压缩大小
    };

    // 这里应该调用CDN API配置压缩
    await new Promise(resolve => setTimeout(resolve, 100));
  }

  /**
   * 配置SSL
   */
  private async configureSSL(): Promise<void> {
    this.logger.log('Configuring CDN SSL');
    
    const sslConfig = {
      certificate: 'auto', // 自动SSL证书
      redirect: true, // HTTP重定向到HTTPS
      hsts: true, // 启用HSTS
    };

    // 这里应该调用CDN API配置SSL
    await new Promise(resolve => setTimeout(resolve, 100));
  }

  /**
   * 监控CDN性能
   */
  async monitorCDNPerformance(): Promise<CDNPerformanceMetrics> {
    this.logger.log('Monitoring CDN performance');

    // 这里应该从CDN提供商获取性能指标
    const metrics: CDNPerformanceMetrics = {
      hitRate: 0.95, // 95%缓存命中率
      responseTime: 50, // 50ms平均响应时间
      bandwidth: 1024 * 1024 * 100, // 100MB/s带宽使用
      errorRate: 0.001, // 0.1%错误率
      regions: [
        { region: 'us-east-1', performance: 0.98 },
        { region: 'eu-west-1', performance: 0.96 },
        { region: 'ap-southeast-1', performance: 0.94 },
      ],
    };

    return metrics;
  }

  /**
   * 优化CDN配置
   */
  async optimizeCDNConfig(metrics: CDNPerformanceMetrics): Promise<void> {
    this.logger.log('Optimizing CDN configuration based on metrics');

    // 根据性能指标调整配置
    if (metrics.hitRate < 0.9) {
      this.logger.log('Low cache hit rate detected, increasing cache TTL');
      await this.increaseCacheTTL();
    }

    if (metrics.responseTime > 100) {
      this.logger.log('High response time detected, optimizing edge locations');
      await this.optimizeEdgeLocations();
    }

    if (metrics.errorRate > 0.01) {
      this.logger.log('High error rate detected, checking CDN health');
      await this.checkCDNHealth();
    }
  }

  private async increaseCacheTTL(): Promise<void> {
    // 增加缓存TTL
    await new Promise(resolve => setTimeout(resolve, 100));
  }

  private async optimizeEdgeLocations(): Promise<void> {
    // 优化边缘节点
    await new Promise(resolve => setTimeout(resolve, 100));
  }

  private async checkCDNHealth(): Promise<void> {
    // 检查CDN健康状态
    await new Promise(resolve => setTimeout(resolve, 100));
  }
}
```

#### 6.4.2 负载均衡优化

**负载均衡器配置**

```typescript
// performance/load-balancer-optimization.service.ts
import { Injectable, Logger } from '@nestjs/common';

export interface LoadBalancerConfig {
  algorithm: 'round-robin' | 'least-connections' | 'ip-hash' | 'weighted';
  healthCheck: {
    enabled: boolean;
    interval: number;
    timeout: number;
    unhealthyThreshold: number;
    healthyThreshold: number;
  };
  stickySessions: {
    enabled: boolean;
    cookieName: string;
    ttl: number;
  };
  sslTermination: {
    enabled: boolean;
    certificatePath: string;
  };
}

export interface ServerNode {
  id: string;
  host: string;
  port: number;
  weight: number;
  health: 'healthy' | 'unhealthy' | 'unknown';
  connections: number;
  responseTime: number;
}

export interface LoadBalancerMetrics {
  totalRequests: number;
  activeConnections: number;
  averageResponseTime: number;
  errorRate: number;
  serverNodes: ServerNode[];
}

@Injectable()
export class LoadBalancerOptimizationService {
  private readonly logger = new Logger(LoadBalancerOptimizationService.name);
  private readonly serverNodes: Map<string, ServerNode> = new Map();

  constructor() {
    this.initializeServerNodes();
  }

  /**
   * 获取优化的负载均衡器配置
   */
  getOptimizedLoadBalancerConfig(): LoadBalancerConfig {
    return {
      algorithm: 'least-connections',
      healthCheck: {
        enabled: true,
        interval: 5000, // 5秒
        timeout: 3000, // 3秒
        unhealthyThreshold: 3,
        healthyThreshold: 2,
      },
      stickySessions: {
        enabled: true,
        cookieName: 'session_id',
        ttl: 3600, // 1小时
      },
      sslTermination: {
        enabled: true,
        certificatePath: '/etc/ssl/certs/example.com.crt',
      },
    };
  }

  /**
   * 初始化服务器节点
   */
  private initializeServerNodes(): void {
    const nodes = [
      { id: 'server-1', host: '192.168.1.10', port: 3000, weight: 1 },
      { id: 'server-2', host: '192.168.1.11', port: 3000, weight: 1 },
      { id: 'server-3', host: '192.168.1.12', port: 3000, weight: 1 },
      { id: 'server-4', host: '192.168.1.13', port: 3000, weight: 1 },
    ];

    for (const node of nodes) {
      this.serverNodes.set(node.id, {
        ...node,
        health: 'unknown',
        connections: 0,
        responseTime: 0,
      });
    }
  }

  /**
   * 健康检查
   */
  async performHealthCheck(): Promise<void> {
    this.logger.log('Performing health check on all server nodes');

    const promises = Array.from(this.serverNodes.values()).map(node =>
      this.checkNodeHealth(node)
    );

    await Promise.allSettled(promises);
  }

  /**
   * 检查单个节点健康状态
   */
  private async checkNodeHealth(node: ServerNode): Promise<void> {
    try {
      const startTime = Date.now();
      const response = await fetch(`http://${node.host}:${node.port}/health`);
      const responseTime = Date.now() - startTime;

      if (response.ok) {
        node.health = 'healthy';
        node.responseTime = responseTime;
        this.logger.debug(`Node ${node.id} is healthy (${responseTime}ms)`);
      } else {
        node.health = 'unhealthy';
        this.logger.warn(`Node ${node.id} is unhealthy (HTTP ${response.status})`);
      }
    } catch (error) {
      node.health = 'unhealthy';
      this.logger.error(`Health check failed for node ${node.id}`, error);
    }
  }

  /**
   * 获取负载均衡器指标
   */
  getLoadBalancerMetrics(): LoadBalancerMetrics {
    const nodes = Array.from(this.serverNodes.values());
    const totalRequests = nodes.reduce((sum, node) => sum + node.connections, 0);
    const averageResponseTime = nodes.reduce((sum, node) => sum + node.responseTime, 0) / nodes.length;
    const errorRate = nodes.filter(node => node.health === 'unhealthy').length / nodes.length;

    return {
      totalRequests,
      activeConnections: totalRequests,
      averageResponseTime,
      errorRate,
      serverNodes: nodes,
    };
  }

  /**
   * 优化负载均衡器配置
   */
  async optimizeLoadBalancerConfig(metrics: LoadBalancerMetrics): Promise<void> {
    this.logger.log('Optimizing load balancer configuration');

    // 根据指标调整配置
    if (metrics.errorRate > 0.1) {
      this.logger.log('High error rate detected, adjusting health check settings');
      await this.adjustHealthCheckSettings();
    }

    if (metrics.averageResponseTime > 200) {
      this.logger.log('High response time detected, optimizing algorithm');
      await this.optimizeAlgorithm();
    }

    // 检查是否需要添加或移除节点
    await this.adjustServerNodes(metrics);
  }

  /**
   * 调整健康检查设置
   */
  private async adjustHealthCheckSettings(): Promise<void> {
    // 增加健康检查频率，减少超时时间
    const optimizedSettings = {
      interval: 3000, // 3秒
      timeout: 2000, // 2秒
      unhealthyThreshold: 2,
      healthyThreshold: 3,
    };

    this.logger.log('Adjusted health check settings', optimizedSettings);
  }

  /**
   * 优化负载均衡算法
   */
  private async optimizeAlgorithm(): Promise<void> {
    // 根据当前负载情况选择最佳算法
    const metrics = this.getLoadBalancerMetrics();
    
    if (metrics.averageResponseTime > 500) {
      this.logger.log('Switching to least-connections algorithm for better performance');
    } else if (metrics.errorRate > 0.05) {
      this.logger.log('Switching to round-robin algorithm for better reliability');
    }
  }

  /**
   * 调整服务器节点
   */
  private async adjustServerNodes(metrics: LoadBalancerMetrics): Promise<void> {
    const healthyNodes = metrics.serverNodes.filter(node => node.health === 'healthy');
    const unhealthyNodes = metrics.serverNodes.filter(node => node.health === 'unhealthy');

    // 如果健康节点太少，尝试恢复不健康的节点
    if (healthyNodes.length < 2 && unhealthyNodes.length > 0) {
      this.logger.log('Attempting to recover unhealthy nodes');
      await this.recoverUnhealthyNodes(unhealthyNodes);
    }

    // 如果负载过高，考虑添加新节点
    if (metrics.activeConnections > 1000) {
      this.logger.log('High load detected, considering adding new server nodes');
      await this.addNewServerNode();
    }
  }

  /**
   * 恢复不健康的节点
   */
  private async recoverUnhealthyNodes(nodes: ServerNode[]): Promise<void> {
    for (const node of nodes) {
      try {
        await this.checkNodeHealth(node);
        if (node.health === 'healthy') {
          this.logger.log(`Successfully recovered node ${node.id}`);
        }
      } catch (error) {
        this.logger.error(`Failed to recover node ${node.id}`, error);
      }
    }
  }

  /**
   * 添加新的服务器节点
   */
  private async addNewServerNode(): Promise<void> {
    // 这里应该实现自动扩展逻辑
    // 例如：启动新的容器实例
    this.logger.log('Adding new server node for load balancing');
    
    const newNodeId = `server-${Date.now()}`;
    const newNode: ServerNode = {
      id: newNodeId,
      host: '192.168.1.14',
      port: 3000,
      weight: 1,
      health: 'unknown',
      connections: 0,
      responseTime: 0,
    };

    this.serverNodes.set(newNodeId, newNode);
    this.logger.log(`Added new server node: ${newNodeId}`);
  }

  /**
   * 配置SSL终止
   */
  async configureSSLTermination(): Promise<void> {
    this.logger.log('Configuring SSL termination');

    const sslConfig = {
      certificate: '/etc/ssl/certs/example.com.crt',
      privateKey: '/etc/ssl/private/example.com.key',
      protocols: ['TLSv1.2', 'TLSv1.3'],
      ciphers: 'ECDHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384',
    };

    // 这里应该配置NGINX或其他负载均衡器的SSL设置
    await new Promise(resolve => setTimeout(resolve, 100));
    
    this.logger.log('SSL termination configured successfully');
  }

  /**
   * 配置会话粘性
   */
  async configureStickySessions(): Promise<void> {
    this.logger.log('Configuring sticky sessions');

    const stickyConfig = {
      cookieName: 'session_id',
      ttl: 3600,
      path: '/',
      httpOnly: true,
      secure: true,
    };

    // 这里应该配置负载均衡器的会话粘性设置
    await new Promise(resolve => setTimeout(resolve, 100));
    
    this.logger.log('Sticky sessions configured successfully');
  }
}
```

#### 6.4.3 网络连接优化

**连接池和连接复用**

```typescript
// performance/network-connection-optimization.service.ts
import { Injectable, Logger } from '@nestjs/common';
import { Agent } from 'http';
import { Agent as HttpsAgent } from 'https';

export interface ConnectionPoolConfig {
  maxSockets: number;
  maxFreeSockets: number;
  timeout: number;
  keepAlive: boolean;
  keepAliveMsecs: number;
  maxCachedSessions: number;
}

export interface NetworkMetrics {
  activeConnections: number;
  idleConnections: number;
  connectionErrors: number;
  averageResponseTime: number;
  throughput: number;
  latency: number;
}

@Injectable()
export class NetworkConnectionOptimizationService {
  private readonly logger = new Logger(NetworkConnectionOptimizationService.name);
  private httpAgent: Agent;
  private httpsAgent: HttpsAgent;
  private metrics: NetworkMetrics = {
    activeConnections: 0,
    idleConnections: 0,
    connectionErrors: 0,
    averageResponseTime: 0,
    throughput: 0,
    latency: 0,
  };

  constructor() {
    this.initializeConnectionAgents();
  }

  /**
   * 初始化连接代理
   */
  private initializeConnectionAgents(): void {
    const config = this.getOptimizedConnectionConfig();

    this.httpAgent = new Agent({
      keepAlive: config.keepAlive,
      keepAliveMsecs: config.keepAliveMsecs,
      maxSockets: config.maxSockets,
      maxFreeSockets: config.maxFreeSockets,
      timeout: config.timeout,
    });

    this.httpsAgent = new HttpsAgent({
      keepAlive: config.keepAlive,
      keepAliveMsecs: config.keepAliveMsecs,
      maxSockets: config.maxSockets,
      maxFreeSockets: config.maxFreeSockets,
      timeout: config.timeout,
      maxCachedSessions: config.maxCachedSessions,
    });

    this.logger.log('Connection agents initialized');
  }

  /**
   * 获取优化的连接配置
   */
  getOptimizedConnectionConfig(): ConnectionPoolConfig {
    return {
      maxSockets: 50,
      maxFreeSockets: 10,
      timeout: 30000, // 30秒
      keepAlive: true,
      keepAliveMsecs: 1000, // 1秒
      maxCachedSessions: 100,
    };
  }

  /**
   * 获取HTTP代理
   */
  getHttpAgent(): Agent {
    return this.httpAgent;
  }

  /**
   * 获取HTTPS代理
   */
  getHttpsAgent(): HttpsAgent {
    return this.httpsAgent;
  }

  /**
   * 优化连接配置
   */
  async optimizeConnectionConfig(metrics: NetworkMetrics): Promise<void> {
    this.logger.log('Optimizing connection configuration based on metrics');

    if (metrics.connectionErrors > 0.05) {
      // 错误率过高，增加超时时间
      await this.increaseTimeout();
    }

    if (metrics.averageResponseTime > 1000) {
      // 响应时间过长，优化连接池
      await this.optimizeConnectionPool();
    }

    if (metrics.activeConnections > 40) {
      // 活跃连接过多，增加最大连接数
      await this.increaseMaxConnections();
    }
  }

  /**
   * 增加超时时间
   */
  private async increaseTimeout(): Promise<void> {
    const newTimeout = 60000; // 60秒
    
    this.httpAgent.options.timeout = newTimeout;
    this.httpsAgent.options.timeout = newTimeout;
    
    this.logger.log(`Increased connection timeout to ${newTimeout}ms`);
  }

  /**
   * 优化连接池
   */
  private async optimizeConnectionPool(): Promise<void> {
    const optimizedConfig = {
      maxSockets: 100,
      maxFreeSockets: 20,
      keepAliveMsecs: 2000,
    };

    this.httpAgent.options.maxSockets = optimizedConfig.maxSockets;
    this.httpAgent.options.maxFreeSockets = optimizedConfig.maxFreeSockets;
    this.httpAgent.options.keepAliveMsecs = optimizedConfig.keepAliveMsecs;

    this.httpsAgent.options.maxSockets = optimizedConfig.maxSockets;
    this.httpsAgent.options.maxFreeSockets = optimizedConfig.maxFreeSockets;
    this.httpsAgent.options.keepAliveMsecs = optimizedConfig.keepAliveMsecs;

    this.logger.log('Optimized connection pool settings', optimizedConfig);
  }

  /**
   * 增加最大连接数
   */
  private async increaseMaxConnections(): Promise<void> {
    const newMaxSockets = 150;
    
    this.httpAgent.options.maxSockets = newMaxSockets;
    this.httpsAgent.options.maxSockets = newMaxSockets;
    
    this.logger.log(`Increased max sockets to ${newMaxSockets}`);
  }

  /**
   * 监控网络性能
   */
  async monitorNetworkPerformance(): Promise<NetworkMetrics> {
    // 更新指标
    this.metrics.activeConnections = this.httpAgent.sockets ? Object.keys(this.httpAgent.sockets).length : 0;
    this.metrics.idleConnections = this.httpAgent.freeSockets ? Object.keys(this.httpAgent.freeSockets).length : 0;

    // 模拟获取其他指标
    this.metrics.connectionErrors = Math.random() * 0.1;
    this.metrics.averageResponseTime = 50 + Math.random() * 100;
    this.metrics.throughput = 1024 * 1024 * (10 + Math.random() * 20); // 10-30 MB/s
    this.metrics.latency = 10 + Math.random() * 50; // 10-60ms

    return this.metrics;
  }

  /**
   * 配置连接复用
   */
  async configureConnectionReuse(): Promise<void> {
    this.logger.log('Configuring connection reuse');

    // 启用连接复用
    this.httpAgent.options.keepAlive = true;
    this.httpsAgent.options.keepAlive = true;

    // 设置合理的空闲连接数
    this.httpAgent.options.maxFreeSockets = 20;
    this.httpsAgent.options.maxFreeSockets = 20;

    // 设置连接超时
    this.httpAgent.options.timeout = 30000;
    this.httpsAgent.options.timeout = 30000;

    this.logger.log('Connection reuse configured successfully');
  }

  /**
   * 清理连接池
   */
  async cleanupConnectionPool(): Promise<void> {
    this.logger.log('Cleaning up connection pool');

    // 清理空闲连接
    this.httpAgent.destroy();
    this.httpsAgent.destroy();

    // 重新初始化
    this.initializeConnectionAgents();

    this.logger.log('Connection pool cleaned up successfully');
  }

  /**
   * 获取连接池状态
   */
  getConnectionPoolStatus(): {
    httpAgent: any;
    httpsAgent: any;
    metrics: NetworkMetrics;
  } {
    return {
      httpAgent: {
        maxSockets: this.httpAgent.options.maxSockets,
        maxFreeSockets: this.httpAgent.options.maxFreeSockets,
        keepAlive: this.httpAgent.options.keepAlive,
        timeout: this.httpAgent.options.timeout,
      },
      httpsAgent: {
        maxSockets: this.httpsAgent.options.maxSockets,
        maxFreeSockets: this.httpsAgent.options.maxFreeSockets,
        keepAlive: this.httpsAgent.options.keepAlive,
        timeout: this.httpsAgent.options.timeout,
      },
      metrics: this.metrics,
    };
  }
}
```
